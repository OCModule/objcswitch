<!DOCTYPE html><html>
<head>
<title>Cocoaheads Smalltalk : Tagged Pointers</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<script src="https://github.com/downloads/gnab/remark/remark-0.3.5.min.js" type="text/javascript"></script>
<style type="text/css" media="screen">
	@import url(http://fonts.googleapis.com/css?family=Quattrocento+Sans:400,700);
	@import url(http://fonts.googleapis.com/css?family=Arvo:700italic);

	h1, h2 {
	  font-family: 'Quattrocento Sans', sans-serif;
	  font-weight: bold;
	}
	p {
	  font-family: 'Quattrocento Sans', sans-serif;
	}
	a {
	  color: #a86;
	  text-decoration: none;
	}
	.center {
	  margin: 0 auto;
	}
	.footnote {
	  position: absolute;
	  bottom: 3em;
	}
	pre {
	  border-left: 0.4em solid #d7d7d7;
	  padding-left: 0.5em;
	}
	code {
	  background: #f4f4f4 !important;
	}
	.position {
	  visibility: hidden;
	}
</style>
</head><body><textarea id="source">


.center.middle
## Cocoaheads Smalltalk
# objcswitch

---
# Objectif

* C switch ne gère que les integers statiques
* idée similaire avec les objets, sans les quirks.
* Apple ajoute des créations d'objets inline dans LLVM 4, c'est dans le même esprit

# Interface choisie

* envisagés : variadiques, objet "Case"
	* problèmes : pas beau, terminateur nil, pas de "default:", virgule entre objet et block

* Implementation choisie
	* Objet "Switch" intermediaire
		* concept trampoline/HOM/mapreduce
		* sert aussi à ne pas polluer NSObject
		* sert de base pour les extensions eventuelles d'api.
	* syntaxe d'appel claire,
	* "default:" possible
	* pas de variadiques dans l'api, donc pas de terminateur nécessaire.
	* hack #1: "empty" selector names 
	* problème : il faut déclarer toutes les variantes de la méthode.

-> show code appels démo et tests

---
# implémentation 

* pas de variadiques dans l'api, mais
	* une seule fonction sert d'implémentation à tous les selecteurs
	* implémentation utilise variadiques
	* are an ugly old shit. You can't count them, you can't convert them easily to an array, you can't forward them to another variadic.
	* variadics in C are passed are regular arguments, you just don't know how many. but they're definitely here on the stack with all their static friends.
		* au moins sur x86. Je n'ai pas essayé sur ARM et ppc.
	* using the selector length to decide the number of arguments :  normally, variadics use either a count arg, a sentinel, of format specifiers.

* ObjC Runtime : ajout de méthodes à l'execution :
	* au moment de l'appel, seulement si la méthode n'existe pas déjà.
		* à l'appel suivant, c'est bon.
	* IMP et SEL
	* sel_getName : it's only a cast if the selector is valid. (selectors are C strings)
	* hidden arguments (self et _cmd) to method implementations
	* type encodings ObjC
		* @encode()

-> show code .m resolveInstanceMethod et objcswitch().

---
# include hacks

-> nécéssité de déclarer toutes les variantes possibles pour éviter les warnings
	-> gros hack sur les #includes

	* __INCLUDE_LEVEL__
		* #include recursifs
	* #include paramétrés -> template programming

-> show code .h, .def.h

---
# améliorations possibles

* comparaison par selecteur ou block custom
* options faciles pour les comparaisons de strings (case-insensitive, diacritics-insensitive…)
* parallélisation
* executer tous les blocks YES, pas seulement le premier
* syntaxe LLVM 4 : encore mieux

---
# links

github/n-b
LLVM 4
parameterized includes

---
# more hacks

	* strlen optimisé à la compilation sur les strings statiques
	* #pragma clang diagnostic push
	* define ivar in @implementation
	* C99-style static C array (with variable length)

</textarea><div id="slideshow"></div></body></html>
